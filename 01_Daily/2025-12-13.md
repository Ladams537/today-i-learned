
"If the Research comes to a bad conclusion, everything below it is f...ed"

Quick prototyping, copy-paste/AI mock-up, feedback from users. Never expecting to upload it prod, so these weir dependencies do not matter, they were purely for feature validation. 


The care needed to not let AI replace the fun parts of coding and end up forcing us to do all the bad parts: 
![[ai_tradeoffs.png]]

Use it to ship quick mock-ups, do initial research, but then build it yourself. 

#### More code != better product 
Often there is an inverse correlation between these things. 

Harder to ship legislation because you have to parse through way more layers of bs before you get to the point: 
* Typewriter
* Word Processor
* LLMs

**Legislation got worse on many fronts because of this, not better.** 

[[Career]]
[[Virtue]]
[[Vitality]]

#### All the process learnings I have had to do to even begin to understand what is good code
You cannot just get people with no understanding of good coding practices or how any of these programming languages work to begin shipping production code. Great for initial mockups, terrible for production systems. Be careful what you allow to happen. 

LLMs have not reduced the amount of time it takes to: 
* reason about behaviour
* identify subtle bugs
* ensure long-term maintainability (seen first hand how it hinders productivity in this domain)

### Two Types of Code

![[two_types_of_code.png]]

Fresh off an era where people said you should write everything in Rust because they were unable to distinguish the difference between these two types. 

Most agents fall under the **throwaway side**. When you don't meaningfully distinguish these two things in your head - you don't see the value in these new tools.

**LLMs** cannot replace **clear thinking, careful review, and thoughful design** - *figure this out after you **know what to build***. 

![[pm_pm_conflict.png]]

#### Question should be: what is the shortest path to a new insight? 
[[Career]]
[[Creativity]]

#### Python Language Knowledge
Multiplying a string by any number less than zero deletes the string. 

If you have a tuple which does not define the second type, you will get a type of Any returned. 

**sys.modules** will keep track of which modules have already been imported in the chain. This prevents you from importing modules twice. 
