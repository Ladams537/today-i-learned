The initial structure design in coding is essential to the program complexity later. See that in the memory problems I just did. If the enum Slot<T> did not have well thought out design, we'd never have been able to solve the question. Cannot always get this right first time, but the ability to see when you have got the structure of the variables wrong and correct it is essential.

### Knowing the exact syntax is nice, but not paramount. **Mechanical Sympathy** is the top priority 
* Hardware Awareness -> Knowing about CPU caches (L1/L2/L3), False Sharing, and Branch Prediction. (This is what we did with the Spin Lock)
* OS Awareness -> Knowing the cost of "asking the manager" (Context Switches, Syscalls, Page Faults)
* Compiler Awareness -> Knowing what the compiler can optimize away and what confuses it (e.g., "Pointer Aliasing" preventing optimisations)

### virtual Dynamic Shared Object
* OS maps a tiny piece of its own memory (e.g. where the clock is ticking) into your program's memory space
* for HFT this can still be too slow -> **course-grained timer**: thread who's only job is to loop forever, read time, and write it to an `AtomicU64`

### Lazy vs Eager Operations
This is a fascinating difference which siginficantly impacts how the code is executed and therefore the logic you need to implement.

Producer/consumer pattern is powerful when used correctly.

## Mechanical Sympathy
The Mental Model: "The noisy room" Imagine the CPU cores are people in a library trying to read the same book.
* **Reading (Shared State)**: 10 people can read the page at the same time. Silence. Efficient.
* **Writing (Exclusive State)**: If one person wants to write on the page, they have to shout "EVERYONE STOP LOOKING!" (Invalidate). This stops all work.
Once you visualize this Bus Traffic, the answer to "How do I make this faster?" becomes obvious:
"Don't shout unless you absolutely have to." (i.e., Don't write unless you check if it's necessary first)

Learned a lot about Python vs Rust, Rust vs C++, basic syntax and conceptual differences between these languages, and more. A day filled with learning.

Extremely happy point today was seeing the AI agent interact and create a TrelloCard on my board with PydanticAI validation. Rewarding feedback loop!

