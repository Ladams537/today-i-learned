How much more my microcontroller has that the one being used in the tutorial. A lot of extension work I would be able to do on his example if I so chose.

Easy to see why adding more hardware gets complicated real fast. You need systems to rank, prioritise, and compare each bit. Just like how going from 12-bit to 16-bit is not a small improvement, but a 16x one.

Vector table stores all the interrupt addresses that we have access to. Some have fixed priority levels; some can be configured.

DMA: (**direct memory access**) allows data transfers to happen in the background without the intervention of the CPU. Allows it to execute other tasks, only being interrupted when a whole data block is available for processing.
* A whole lot of parameters need configured when you are dealing with DMA
* Only one channel can be active at the same time in a stream
* Request mapping table shows you what you need to configure
* Arbiter used for handling DMA stream priority. If same level, hardware priority is used
* Circular mode: handling circular buffers; Normal mode: reaches zero and stream is disabled
* DMA FIFO allows data packing/unpacking and/or burst mode to be used -> saw this coming up in distributed-limit-order book 

The most important quality one can have is to see a problem and have a systematic way of going about solving issues. The most common type of problem you will encounter in life are unknown. They may follow a similar pattern to what you have seen before, but they will be new. You then have to slowly piece things together, research, and innovate new ways of solving it by joining tools together. Many problems can be solved with embedded systems. Just got to look. But then again, might be solved by another solution. Become a problem solver. Not a one-trick-pony.

I2C: (**inter-integrated circuit**)
* **SCL**: serial clock (synchronising data between master and slave);**SDA**: serial data
* transactions initiated and completed by the master
* all messages have an address frame and a data frame
* data placed on SDA line when SCL goes low, sampled when SCL goes high
* standard mode: 100KHz; fast-mode: 400KHz, fast-mode-plus: 1MHz; high-speed-mode: 3.4MHz
* duty-cycle: **how much time is the clock high vs low**

SPI: (**serial peripheral interface**)
* synchronous and full-duplex between master and several slave devices
* two pins for data transfer: **SDIN** (**MOSI**) and **SDO** (**MISO**)
* **SCLK** (**SCK**) pin to synchronise transfer
* **CE** (**SS**) pin to initiate and terminate transfer
* no addresses unlike I2C
* can configure which end we want to send data
* clock phase and polarity -> master/slave must agree on these
* **NSS**: software and hardware mode
* **TI**: another mode, must be in NSS hardware mode to use

No one piece of the puzzle is all that hard. It is in combining the pieces together to meet a real-world need where it gets infinitely complex.

Bare-metal was nice to highlight the importance of aliases within code. Can be often overlooked when coding at a higher level for me personally, but non-negotiable at bare-metal level to follow along even a one file codebase. Makes scaling and collaboratng infinitely easier if you use good aliases coupled with good comments at the tricky logic parts.


 
